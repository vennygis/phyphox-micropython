# Simple workflow for deploying static content to GitHub Pages
name: Deploy static content to Pages

on:
  # Runs on pushes targeting the default branch
  push:
    branches: ["main"]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # Single deploy job since we're just deploying
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Pages
        uses: actions/configure-pages@v5
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          # Upload entire repository
          path: '.'
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

            - name: Cache
  uses: actions/cache@v5.0.2
  with:
    # A list of files, directories, and wildcard patterns to cache and restore
    path: 
    # An explicit key for restoring and saving the cache
    key: 
    # An ordered multiline string listing the prefix-matched keys, that are used for restoring stale cache if no cache hit occurred for key. Note `cache-hit` returns false in this case.
    restore-keys: # optional
    # The chunk size used to split up large files during upload, in bytes
    upload-chunk-size: # optional
    # An optional boolean when enabled, allows windows runners to save or restore caches that can be restored or saved respectively on other platforms
    enableCrossOsArchive: # optional, default is false
    # Fail the workflow if cache entry is not found
    fail-on-cache-miss: # optional, default is false
    # Check if a cache entry exists for the given input(s) (key, restore-keys) without downloading the cache
    lookup-only: # optional, default is false
    # Run the post step to save the cache even if another step before fails
    save-always: # optional, default is false
                - name: terraform-plan-storage
  # You may pin to the exact commit or the version.
  # uses: cloudposse/github-action-terraform-plan-storage@55b5d342c1eefee79e661b2709e91b19b4361c6d
  uses: cloudposse/github-action-terraform-plan-storage@1.14.0
  with:
    # which action to perform. Valid values are: 'storePlan', 'getPlan', 'taintPlan'
    action: # default is storePlan
    # the name of the Azure Blob Storage account to store the plan file
    blobAccountName: # optional
    # the name of the Azure Blob Storage container to store the plan file
    blobContainerName: # optional
    # the name of the S3 bucket to store the plan file
    bucketName: # optional, default is terraform-plan-storage
    # Commit SHA to use for fetching plan
    commitSHA: # optional, default is 
    # the name of the component corresponding to the plan file
    component: # optional
    # the connection string to the CosmosDB account to store the metadata
    cosmosConnectionString: # optional
    # the name of the CosmosDB container to store the metadata
    cosmosContainerName: # optional
    # the name of the CosmosDB database to store the metadata
    cosmosDatabaseName: # optional
    # the endpoint of the CosmosDB account to store the metadata
    cosmosEndpoint: # optional
    # Fail if plan is missing
    failOnMissingPlan: # optional, default is true
    # the type of repository where the plan file is stored. Valid values are: 'dynamo', 'cosmodb'
    metadataRepositoryType: # optional, default is dynamo
    # path to the Terraform plan file. Required for 'storePlan' and 'getPlan' actions
    planPath: # optional
    # the type of repository where the metadata is stored. Valid values are: 's3', 'azureblob'
    planRepositoryType: # optional, default is s3
    # the name of the stack corresponding to the plan file
    stack: # optional
    # the name of the dynamodb table to store metadata
    tableName: # optional, default is terraform-plan-storage
                - name: Download a Build Artifact
  uses: actions/download-artifact@v7.0.0
  with:
    # Name of the artifact to download. If unspecified, all artifacts for the run are downloaded.
    name: # optional
    # IDs of the artifacts to download, comma-separated. Either inputs `artifact-ids` or `name` can be used, but not both.
    artifact-ids: # optional
    # Destination path. Supports basic tilde expansion. Defaults to $GITHUB_WORKSPACE
    path: # optional
    # A glob pattern matching the artifacts that should be downloaded. Ignored if name is specified.
    pattern: # optional
    # When multiple artifacts are matched, this changes the behavior of the destination directories. If true, the downloaded artifacts will be in the same directory specified by path. If false, the downloaded artifacts will be extracted into individual named directories within the specified path.
    merge-multiple: # optional, default is false
    # The GitHub token used to authenticate with the GitHub API. This is required when downloading artifacts from a different repository or from a different workflow run. If this is not specified, the action will attempt to download artifacts from the current repository and the current workflow run.
    github-token: # optional
    # The repository owner and the repository name joined together by "/". If github-token is specified, this is the repository that artifacts will be downloaded from.
    repository: # optional, default is ${{ github.repository }}
    # The id of the workflow run where the desired download artifact was uploaded from. If github-token is specified, this is the run that artifacts will be downloaded from.
    run-id: # optional, default is ${{ github.run_id }}
          
          
          
